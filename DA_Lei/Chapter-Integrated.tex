\chapter{Keyword Query Routing for Data Web Search}\label{qr}

In this chapter, we propose a novel \emph{virtual document} based approach to address the problem of
keyword query routing for efficient keyword search on data web (see Section~\ref{pre:ksdw}). We
develop an effective ranking mechanism by taking into account both IR-style relevance and structural
compactness in order to select the most relevant data sources for a given keyword query and directe
the keywords in the query to only the appropriate sources. In Section~\ref{qr:overview}, we present
an overview of our approach. Section~\ref{qr:preprocessing} describes the offline process where the
data are preprocessed to compute the virtual documents. We present the metrics to rank the data
sources in section~\ref{qr:ranking}. At last, section~\ref{qr:queryprocess} introduces the query
processing algorithm.

\section{Overview of Our Approach}\label{qr:overview}
We start with an overview of the different steps involved in the process of keyword query routing. We
detail the different steps of our approach in following sections.

\paragraph{Preprocessing}
Given the integrated data graph $G_{ID}$, we first extract all the maximal r-radius subgraphs.
For each maximal r-radius subgraph, the keywords contained in it can be seen as a {\em virtual
document}. Since these keywords might come from different data sources, for each keyword in a
virtual document we track and store the corresponding data sources.
After that we extract the keyword pairs (combinitions of two keywords) in all virtual documents and
construct the {\em keyword index} which maps each keyword pair to the list of corresponding virtual
documents that contain this keyword pair. Since we are interested in the top-k query routing
plans, keyword pairs are associated with {\em scores}, which can be computed off-line and stored in the
keyword index. The scoring functions take into account both IR-style and structural relevance.Intuitively, if a virtual document contains all keywords of a user query with high score, we candirect the keywords to corresponding data sources associated with them. 
Note that if there are a large number of overlapped virtual documents, in other words, the virtual
documents have many shared keywords, it might lead to low efficiency at the time of query processing
due to the long list of virtual documents returned from the keyword index. We devise a quality-based
clustering method to group the relevant virtual documents in the keyword index into clusters. This
clustering process is keyword-sensitive and its goal is to minimize the number of keywords shared by
different clusters of virtual documents and accordingly shorten the list of virtual documents in the
keyword index. It is worth noting that this quality-based clustering method allows a trade-off
between effectiveness and efficiency for query processing.\paragraph{Query Processing}
Given a keyword query $K = \{k_1,k_2,\ldots,k_m\}$, we first retrieve the lists of virtual documents
(more precisely, the clustered virtual documents) associated with corresponding scores for each
keyword pair according to the keyword index. Then, we adopt existing top-k algorithms to
progressively identify the virtual documents in a descending order, where each virtual documents can
generate one or more query routing plans. However, some virtual documents might correspond to the
same query routing plan, thus we maintain a heap of the query routing plans. When a new virtual
document is found, if the corresponding query routing plans are already in the heap, the scores will
be added to them, otherwise the new query routing plans will be inserted into the heap. This process
continues until the top-k query routing plans have been achieved or no more virtual documents can be
found.
\section{Data Preprocessing}\label{qr:preprocessing}

%content

\subsection{Computation of Virtual Documents}\label{qr:vdcompute}

%content

\subsection{Virtual Documents Clustering}\label{qr:vdcluster}

%content

\section{Ranking Functions}\label{qr:ranking}

%content

\section{Query Processing}\label{qr:queryprocess}

%content

\section{Implementation}\label{qr:implementation}

%content


